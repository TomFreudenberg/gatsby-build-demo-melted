"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var fs = require("fs");

var path = require("path");

var Promise = require("bluebird");

var sharp = require("sharp");

var _require = require("./common.js"),
    defaultIcons = _require.defaultIcons,
    doesIconExist = _require.doesIconExist,
    addDigestToPath = _require.addDigestToPath,
    createContentDigest = _require.createContentDigest;

sharp.simd(true);

try {
  // Handle Sharp's concurrency based on the Gatsby CPU count
  // See: http://sharp.pixelplumbing.com/en/stable/api-utility/#concurrency
  // See: https://www.gatsbyjs.org/docs/multi-core-builds/
  var cpuCoreCount = require("gatsby/dist/utils/cpu-core-count");

  sharp.concurrency(cpuCoreCount());
} catch (_unused) {// if above throws error this probably means that used Gatsby version
  // doesn't support cpu-core-count utility.
}

function generateIcons(icons, srcIcon) {
  return Promise.map(icons, function (icon) {
    var size = parseInt(icon.sizes.substring(0, icon.sizes.lastIndexOf("x")));
    var imgPath = path.join("public", icon.src); // For vector graphics, instruct sharp to use a pixel density
    // suitable for the resolution we're rasterizing to.
    // For pixel graphics sources this has no effect.
    // Sharp accept density from 1 to 2400

    var density = Math.min(2400, Math.max(1, size));
    return sharp(srcIcon, {
      density: density
    }).resize(size).toFile(imgPath).then(function () {});
  });
}

exports.onPostBootstrap =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(args, pluginOptions) {
    var icon, manifest, iconPath, cacheMode, iconDigest;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            icon = pluginOptions.icon, manifest = (0, _objectWithoutPropertiesLoose2.default)(pluginOptions, ["icon"]); // Delete options we won't pass to the manifest.webmanifest.

            delete manifest.plugins;
            delete manifest.legacy;
            delete manifest.theme_color_in_head;
            delete manifest.cache_busting_mode;
            delete manifest.crossOrigin; // If icons are not manually defined, use the default icon set.

            if (!manifest.icons) {
              manifest.icons = defaultIcons;
            } // Determine destination path for icons.


            iconPath = path.join("public", path.dirname(manifest.icons[0].src)); //create destination directory if it doesn't exist

            if (!fs.existsSync(iconPath)) {
              fs.mkdirSync(iconPath);
            } // Only auto-generate icons if a src icon is defined.


            if (!(icon !== undefined)) {
              _context.next = 20;
              break;
            }

            if (doesIconExist(icon)) {
              _context.next = 12;
              break;
            }

            throw "icon (" + icon + ") does not exist as defined in gatsby-config.js. Make sure the file exists relative to the root of the site.";

          case 12:
            //add cache busting
            cacheMode = typeof pluginOptions.cache_busting_mode !== "undefined" ? pluginOptions.cache_busting_mode : "query"; //if cacheBusting is being done via url query icons must be generated before cache busting runs

            if (!(cacheMode === "query")) {
              _context.next = 16;
              break;
            }

            _context.next = 16;
            return generateIcons(manifest.icons, icon);

          case 16:
            if (cacheMode !== "none") {
              iconDigest = createContentDigest(fs.readFileSync(icon));
              manifest.icons.forEach(function (icon) {
                icon.src = addDigestToPath(icon.src, iconDigest, cacheMode);
              });
            } //if file names are being modified by cacheBusting icons must be generated after cache busting runs


            if (!(cacheMode !== "query")) {
              _context.next = 20;
              break;
            }

            _context.next = 20;
            return generateIcons(manifest.icons, icon);

          case 20:
            //Write manifest
            fs.writeFileSync(path.join("public", "manifest.webmanifest"), JSON.stringify(manifest));

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();